# SPDX-FileCopyrightText: Copyright (c) 2024-2025 NVIDIA CORPORATION & AFFILIATES.
#                         All rights reserved.
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import sys
import json
import shlex
import shutil
import textwrap
from pathlib import Path
from typing import TYPE_CHECKING, Any, TypeAlias

import pytest

from ..logger import Logger
from ..main import basic_configure
from ..manager import ConfigurationManager
from ..package.main_package import _detect_num_cpus
from .fixtures.dummy_main_module import DummyMainModule

if TYPE_CHECKING:
    from ..cmake.cmaker import CMakeCommandSpec


@pytest.fixture(autouse=True)
def setup_cmake_project(AEDIFIX_PYTEST_DIR: Path) -> None:
    main_cpp_template = textwrap.dedent(
        r"""
        #include <iostream>

        int main(int argc, char *argv[])
        {
          std::cout << "hello, world!\n";
          return 0;
        }
        """
    ).strip()
    cmakelists_template = textwrap.dedent(
        r"""
        cmake_minimum_required(VERSION 3.13...3.16 FATAL_ERROR)

        project(example_exec VERSION 0.0.1 LANGUAGES C CXX)

        add_executable(example_exec src/main.cpp)
        target_compile_features(example_exec PRIVATE cxx_auto_type)

        install(TARGETS example_exec)

        set(data "{}")
        foreach(var IN LISTS AEDIFIX_EXPORT_VARIABLES)
          string(JSON data SET "${data}" "${var}" "\"${${var}}\"")
        endforeach()
        file(WRITE "${AEDIFIX_EXPORT_CONFIG_PATH}" "${data}")
        """
    ).strip()
    src_dir = AEDIFIX_PYTEST_DIR / "src"
    src_dir.mkdir()
    (src_dir / "main.cpp").write_text(main_cpp_template)
    (AEDIFIX_PYTEST_DIR / "CMakeLists.txt").write_text(cmakelists_template)


def shutil_which(thing: str) -> Path:
    ret = shutil.which(thing)
    assert ret is not None
    return Path(ret)


Argv: TypeAlias = list[str]


class TestInfo:
    # tell pytest to ignore this class, even though it starts with "Test"
    __test__ = False

    def __init__(
        self,
        AEDIFIX_PYTEST_DIR: Path,
        AEDIFIX_PYTEST_ARCH: str,
        generator: str | None = None,
    ) -> None:
        self.AEDIFIX_PYTEST_DIR = AEDIFIX_PYTEST_DIR
        self.AEDIFIX_PYTEST_ARCH = AEDIFIX_PYTEST_ARCH
        self.arch_dir = self.AEDIFIX_PYTEST_DIR / self.AEDIFIX_PYTEST_ARCH
        self.configure_log = self.AEDIFIX_PYTEST_DIR / "configure.log"
        self.backup_configure_log = self.arch_dir / "configure.log"
        self.reconfigure = (
            self.arch_dir / f"reconfigure-{self.AEDIFIX_PYTEST_ARCH}.py"
        )
        self.reconfigure_symlink = (
            self.AEDIFIX_PYTEST_DIR / self.reconfigure.name
        )
        self.cmake_dir = self.arch_dir / "cmake_build"
        self.cmakecache_txt = self.cmake_dir / "CMakeCache.txt"
        self.command_spec = self.cmake_dir / "aedifix_cmake_command_spec.json"
        self.cmake_exe = Path(shutil_which("cmake")).resolve()
        if generator is None:
            generator = "Ninja" if shutil.which("ninja") else "Unix Makefiles"
        self.generator = generator
        self.export_config_path = self.cmake_dir / "aedifix_export_config.json"

    def pre_test(self) -> None:
        assert not self.arch_dir.exists()
        assert not self.configure_log.exists()
        assert not self.backup_configure_log.exists()
        assert not self.reconfigure.exists()
        assert not self.reconfigure_symlink.exists()
        assert not self.cmake_dir.exists()
        assert not self.cmakecache_txt.exists()
        assert not self.command_spec.exists()

    def post_test(self, expected_spec: CMakeCommandSpec) -> None:
        # basics
        assert self.arch_dir.is_dir()
        # configure.log
        assert self.configure_log.exists()
        assert self.configure_log.is_file()

        assert self.backup_configure_log.exists()
        assert self.backup_configure_log.is_file()
        assert (
            self.configure_log.read_text()
            == self.backup_configure_log.read_text()
        )

        # reconfigure
        assert self.reconfigure.exists()
        assert self.reconfigure.is_file()

        assert self.reconfigure_symlink.exists()
        assert self.reconfigure_symlink.is_symlink()
        assert (
            self.AEDIFIX_PYTEST_DIR / self.reconfigure_symlink.readlink()
            == self.reconfigure
        )

        # cmake dir
        assert self.cmake_dir.exists()
        assert self.cmake_dir.is_dir()

        # TODO: check more cmake cache!
        assert self.cmakecache_txt.exists()
        assert self.cmakecache_txt.is_file()
        cache_header_lines = [
            "# This is the CMakeCache file.\n",
            f"# For build in directory: {self.cmake_dir}\n",
            f"# It was generated by CMake: {self.cmake_exe}\n",
            "# You can edit this file to change values found and used by cmake.\n",  # noqa: E501
            "# If you do not want to change any of the values, simply exit the editor.\n",  # noqa: E501
            "# If you do want to change a value, simply edit, save, and exit the editor.\n",  # noqa: E501
            "# The syntax for the file is as follows:\n",
            "# KEY:TYPE=VALUE\n",
            "# KEY is the name of a variable in the cache.\n",
            "# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.\n",  # noqa: E501
            "# VALUE is the current value for the KEY.\n",
        ]
        idx = 0
        with self.cmakecache_txt.open() as fd:
            # Exploit the fact that zip() will end when the shortest iterator
            # is exhausted (i.e. cache_header_lines in this case)
            for line, expected in zip(fd, cache_header_lines):
                assert line == expected
                idx += 1
        # But double check the fact that cache_header_lines was indeed the
        # shortest
        assert idx == len(cache_header_lines)

        assert self.command_spec.exists()
        assert self.command_spec.is_file()
        with self.command_spec.open() as fd:
            spec = json.load(fd)

        assert "CMAKE_COMMANDS" in spec
        # Remove the export variables entry. It's too odious to test properly
        # (and would break the second anyone added any new flags), so just do
        # some minor tests
        cmake_commands = spec["CMAKE_COMMANDS"]
        for idx, val in enumerate(cmake_commands):
            if val.startswith("-DAEDIFIX_EXPORT_VARIABLES"):
                assert "CMAKE_C_COMPILER" in val
                assert "CMAKE_CXX_COMPILER" in val
                assert "CMAKE_COMMAND" in val
                assert "CMAKE_GENERATOR" in val
                assert len(val.split(";")) > 20
                del cmake_commands[idx]
                break
        else:
            pytest.fail("Did not find export variables in cmake command")
        assert spec == expected_spec


class SpecialException(Exception):
    pass


@pytest.mark.slow
class TestMain:
    def test_basic_configure_bad_init(
        self, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        exn_mess = "Throwing from __init__"

        def throwing_init(*args: Any, **kwargs: Any) -> None:
            raise SpecialException(exn_mess)

        monkeypatch.setattr(ConfigurationManager, "__init__", throwing_init)
        with pytest.raises(SpecialException, match=exn_mess):
            basic_configure((), DummyMainModule)

    def test_basic_configure_bad_halfway(
        self, monkeypatch: pytest.MonkeyPatch, AEDIFIX_PYTEST_DIR: Path
    ) -> None:
        exn_mess = "Throwing from setup"

        def throwing_setup(*args: Any, **kwargs: Any) -> None:
            raise SpecialException(exn_mess)

        monkeypatch.setattr(ConfigurationManager, "setup", throwing_setup)

        ret = basic_configure((), DummyMainModule)
        assert ret != 0

        configure_log = AEDIFIX_PYTEST_DIR / "configure.log"
        assert configure_log.is_file()
        config_log_text = configure_log.read_text().strip()
        assert config_log_text

        logger = Logger(AEDIFIX_PYTEST_DIR / "dummy.log")
        expected_lines = logger.build_multiline_message(
            sup_title="***** CONFIGURATION CRASH *****",
            divider_char="-",
            text=(
                f"{exn_mess}, please see {configure_log} for additional "
                "details."
            ),
        ).splitlines()
        banner = "=" * (logger.console.width - 1)
        expected_lines.insert(0, banner)
        expected_lines.append(banner)
        config_log_lines = set(config_log_text.splitlines())
        assert set(expected_lines) <= config_log_lines

    def test_basic_configure_bare(
        self, AEDIFIX_PYTEST_DIR: Path, AEDIFIX_PYTEST_ARCH: str
    ) -> None:
        test_info = TestInfo(AEDIFIX_PYTEST_DIR, AEDIFIX_PYTEST_ARCH)
        test_info.pre_test()

        num_cpus = _detect_num_cpus()
        argv: Argv = []
        expected_spec: CMakeCommandSpec = {
            "CMAKE_EXECUTABLE": f"{test_info.cmake_exe}",
            "CMAKE_GENERATOR": test_info.generator,
            "SOURCE_DIR": f"{AEDIFIX_PYTEST_DIR}",
            "BUILD_DIR": f"{test_info.cmake_dir}",
            "CMAKE_COMMANDS": [
                "--log-context",
                "--log-level=DEBUG",
                "-DAEDIFIX:BOOL=ON",
                f"-DAEDIFIX_PYTEST_ARCH:STRING='{AEDIFIX_PYTEST_ARCH}'",
                f"-DAEDIFIX_PYTEST_DIR:PATH='{AEDIFIX_PYTEST_DIR}'",
                "-DDUMMYMAINMODULE_CONFIGURE_OPTIONS:STRING=",
                f"-DAEDIFIX_EXPORT_CONFIG_PATH:FILEPATH='{test_info.export_config_path}'",
                "-DBUILD_SHARED_LIBS:BOOL=ON",
                f"-DCMAKE_BUILD_PARALLEL_LEVEL:STRING={num_cpus}",
                "-DCMAKE_BUILD_TYPE:STRING=Release",
                "-DCMAKE_COLOR_DIAGNOSTICS:BOOL=ON",
                "-DCMAKE_COLOR_MAKEFILE:BOOL=ON",
                "-DCMAKE_CXX_FLAGS:STRING=-O3",
                "-DCMAKE_C_FLAGS:STRING=-O3",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON",
            ],
        }

        ret = basic_configure(argv, DummyMainModule)
        assert ret == 0
        test_info.post_test(expected_spec)

    def test_basic_configure_release(
        self, AEDIFIX_PYTEST_DIR: Path, AEDIFIX_PYTEST_ARCH: str
    ) -> None:
        test_info = TestInfo(AEDIFIX_PYTEST_DIR, AEDIFIX_PYTEST_ARCH)
        test_info.pre_test()

        num_cpus = _detect_num_cpus()
        argv: Argv = ["--build-type=release"]
        argv_str = shlex.join(argv)
        expected_spec: CMakeCommandSpec = {
            "CMAKE_EXECUTABLE": f"{test_info.cmake_exe}",
            "CMAKE_GENERATOR": test_info.generator,
            "SOURCE_DIR": f"{AEDIFIX_PYTEST_DIR}",
            "BUILD_DIR": f"{test_info.cmake_dir}",
            "CMAKE_COMMANDS": [
                "--log-context",
                "--log-level=DEBUG",
                "-DAEDIFIX:BOOL=ON",
                f"-DAEDIFIX_PYTEST_ARCH:STRING='{AEDIFIX_PYTEST_ARCH}'",
                f"-DAEDIFIX_PYTEST_DIR:PATH='{AEDIFIX_PYTEST_DIR}'",
                f"-DDUMMYMAINMODULE_CONFIGURE_OPTIONS:STRING={argv_str}",
                f"-DAEDIFIX_EXPORT_CONFIG_PATH:FILEPATH='{test_info.export_config_path}'",
                "-DBUILD_SHARED_LIBS:BOOL=ON",
                f"-DCMAKE_BUILD_PARALLEL_LEVEL:STRING={num_cpus}",
                "-DCMAKE_BUILD_TYPE:STRING=Release",
                "-DCMAKE_COLOR_DIAGNOSTICS:BOOL=ON",
                "-DCMAKE_COLOR_MAKEFILE:BOOL=ON",
                "-DCMAKE_CXX_FLAGS:STRING=-O3",
                "-DCMAKE_C_FLAGS:STRING=-O3",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON",
            ],
        }

        ret = basic_configure(argv, DummyMainModule)
        assert ret == 0
        test_info.post_test(expected_spec)

    def test_basic_configure_relwithdebinfo(
        self, AEDIFIX_PYTEST_DIR: Path, AEDIFIX_PYTEST_ARCH: str
    ) -> None:
        test_info = TestInfo(AEDIFIX_PYTEST_DIR, AEDIFIX_PYTEST_ARCH)
        test_info.pre_test()

        num_cpus = _detect_num_cpus()
        argv: Argv = ["--build-type=relwithdebinfo"]
        argv_str = shlex.join(argv)
        expected_spec: CMakeCommandSpec = {
            "CMAKE_EXECUTABLE": f"{test_info.cmake_exe}",
            "CMAKE_GENERATOR": test_info.generator,
            "SOURCE_DIR": f"{AEDIFIX_PYTEST_DIR}",
            "BUILD_DIR": f"{test_info.cmake_dir}",
            "CMAKE_COMMANDS": [
                "--log-context",
                "--log-level=DEBUG",
                "-DAEDIFIX:BOOL=ON",
                f"-DAEDIFIX_PYTEST_ARCH:STRING='{AEDIFIX_PYTEST_ARCH}'",
                f"-DAEDIFIX_PYTEST_DIR:PATH='{AEDIFIX_PYTEST_DIR}'",
                f"-DDUMMYMAINMODULE_CONFIGURE_OPTIONS:STRING={argv_str}",
                f"-DAEDIFIX_EXPORT_CONFIG_PATH:FILEPATH='{test_info.export_config_path}'",
                "-DBUILD_SHARED_LIBS:BOOL=ON",
                f"-DCMAKE_BUILD_PARALLEL_LEVEL:STRING={num_cpus}",
                "-DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo",
                "-DCMAKE_COLOR_DIAGNOSTICS:BOOL=ON",
                "-DCMAKE_COLOR_MAKEFILE:BOOL=ON",
                "-DCMAKE_CXX_FLAGS:STRING='-O0 -g -g3 -O3'",
                "-DCMAKE_C_FLAGS:STRING='-O0 -g -g3 -O3'",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON",
            ],
        }

        ret = basic_configure(argv, DummyMainModule)
        assert ret == 0
        test_info.post_test(expected_spec)

    def test_basic_configure_clang_debug(
        self, AEDIFIX_PYTEST_DIR: Path, AEDIFIX_PYTEST_ARCH: str
    ) -> None:
        test_info = TestInfo(
            AEDIFIX_PYTEST_DIR, AEDIFIX_PYTEST_ARCH, generator="Unix Makefiles"
        )
        test_info.pre_test()

        # This causes it to be joined as a string that is too long
        flags = " ".join(  # noqa: FLY002
            [
                "-O0",
                "-g3",
                "-fstack-protector",
                "-Walloca",
                "-Wdeprecated",
                "-Wimplicit-fallthrough",
                "-fdiagnostics-show-template-tree",
                "-Wignored-qualifiers",
                "-Wmissing-field-initializers",
                "-Wextra",
                "-fsanitize=address,undefined,bounds",
            ]
        )

        cc = Path(shutil_which("clang"))
        cxx = Path(shutil_which("clang++"))
        num_cpus = _detect_num_cpus()
        argv: Argv = [
            f"--with-cc={cc}",
            f"--with-cxx={cxx}",
            "--build-type=debug",
            "--library-linkage=static",
            f"--cmake-generator={test_info.generator}",
            f"--CFLAGS={flags}",
            f"--CXXFLAGS={flags}",
        ]
        argv_str = shlex.join(argv)
        expected_spec: CMakeCommandSpec = {
            "CMAKE_EXECUTABLE": f"{test_info.cmake_exe}",
            "CMAKE_GENERATOR": test_info.generator,
            "SOURCE_DIR": f"{AEDIFIX_PYTEST_DIR}",
            "BUILD_DIR": f"{test_info.cmake_dir}",
            "CMAKE_COMMANDS": [
                "--log-context",
                "--log-level=DEBUG",
                "-DAEDIFIX:BOOL=ON",
                f"-DAEDIFIX_PYTEST_ARCH:STRING='{AEDIFIX_PYTEST_ARCH}'",
                f"-DAEDIFIX_PYTEST_DIR:PATH='{AEDIFIX_PYTEST_DIR}'",
                f"-DDUMMYMAINMODULE_CONFIGURE_OPTIONS:STRING={argv_str}",
                f"-DAEDIFIX_EXPORT_CONFIG_PATH:FILEPATH='{test_info.export_config_path}'",
                "-DBUILD_SHARED_LIBS:BOOL=OFF",
                f"-DCMAKE_BUILD_PARALLEL_LEVEL:STRING={num_cpus}",
                "-DCMAKE_BUILD_TYPE:STRING=Debug",
                "-DCMAKE_COLOR_DIAGNOSTICS:BOOL=ON",
                "-DCMAKE_COLOR_MAKEFILE:BOOL=ON",
                f"-DCMAKE_CXX_COMPILER:FILEPATH={cxx}",
                f"-DCMAKE_CXX_FLAGS:STRING='{flags}'",
                f"-DCMAKE_C_COMPILER:FILEPATH={cc}",
                f"-DCMAKE_C_FLAGS:STRING='{flags}'",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON",
            ],
        }

        ret = basic_configure(argv, DummyMainModule)
        assert ret == 0
        test_info.post_test(expected_spec)

    def test_extra_argv(
        self, AEDIFIX_PYTEST_DIR: Path, AEDIFIX_PYTEST_ARCH: str
    ) -> None:
        test_info = TestInfo(
            AEDIFIX_PYTEST_DIR, AEDIFIX_PYTEST_ARCH, generator="Unix Makefiles"
        )
        test_info.pre_test()

        num_cpus = _detect_num_cpus()
        argv: Argv = [
            "--build-type=relwithdebinfo",
            f"--cmake-generator={test_info.generator}",
            "--",
            "-DFOO=BAR",
            "-DBAZ=1234",
        ]
        argv_str = shlex.join(argv)
        expected_spec: CMakeCommandSpec = {
            "CMAKE_EXECUTABLE": f"{test_info.cmake_exe}",
            "CMAKE_GENERATOR": test_info.generator,
            "SOURCE_DIR": f"{AEDIFIX_PYTEST_DIR}",
            "BUILD_DIR": f"{test_info.cmake_dir}",
            "CMAKE_COMMANDS": [
                "--log-context",
                "--log-level=DEBUG",
                "-DAEDIFIX:BOOL=ON",
                f"-DAEDIFIX_PYTEST_ARCH:STRING='{AEDIFIX_PYTEST_ARCH}'",
                f"-DAEDIFIX_PYTEST_DIR:PATH='{AEDIFIX_PYTEST_DIR}'",
                f"-DDUMMYMAINMODULE_CONFIGURE_OPTIONS:STRING={argv_str}",
                f"-DAEDIFIX_EXPORT_CONFIG_PATH:FILEPATH='{test_info.export_config_path}'",
                "-DBUILD_SHARED_LIBS:BOOL=ON",
                f"-DCMAKE_BUILD_PARALLEL_LEVEL:STRING={num_cpus}",
                "-DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo",
                "-DCMAKE_COLOR_DIAGNOSTICS:BOOL=ON",
                "-DCMAKE_COLOR_MAKEFILE:BOOL=ON",
                "-DCMAKE_CXX_FLAGS:STRING='-O0 -g -g3 -O3'",
                "-DCMAKE_C_FLAGS:STRING='-O0 -g -g3 -O3'",
                "-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON",
                "-DFOO=BAR",
                "-DBAZ=1234",
            ],
        }

        ret = basic_configure(argv, DummyMainModule)
        assert ret == 0
        test_info.post_test(expected_spec)


if __name__ == "__main__":
    sys.exit(pytest.main())
