# SPDX-FileCopyrightText: Copyright (c) 2025-2025 NVIDIA CORPORATION & AFFILIATES.
# All rights reserved.
# SPDX-License-Identifier: Apache-2.0

from libcpp cimport bool
from libcpp.string cimport string as std_string
from libcpp.unordered_map cimport unordered_map as std_unordered_map

from ..._lib.task.task_context cimport _TaskContext, TaskContext
from ..._lib.task.task_info cimport _TaskInfo
from ..._lib.task.task_config cimport _TaskConfig
from ..._lib.runtime.library cimport _Library
from ..._lib.utilities.typedefs cimport TaskFuncPtr, VariantImpl
from ..._lib.utilities.abort cimport LEGATE_ABORT

import gc

cdef dict[_GlobalTaskID, dict[VariantCode, object]] _gid_to_variant_callbacks = {}

cdef void register_variants(_GlobalTaskID global_task_id, dict variants):
    if global_task_id in _gid_to_variant_callbacks:
        m = f"Already registered task (global id: {global_task_id})"
        raise AssertionError(m)

    _gid_to_variant_callbacks[global_task_id] = variants


cdef void py_variant_inner(TaskContext ctx):
    cdef _GlobalTaskID global_task_id = ctx.get_task_id()
    cdef dict variant_callbacks = _gid_to_variant_callbacks.get(global_task_id)

    assert variant_callbacks is not None, (
        f"Task (global task id {global_task_id}) did not have any variant "
        "callbacks registered"
    )

    cdef VariantCode variant_kind = ctx.get_variant_kind()
    cdef object py_callback = variant_callbacks.get(variant_kind)

    assert py_callback is not None, (
        f"Task (global task id {global_task_id}) did not have a variant "
        f"registered for variant kind: {variant_kind}"
    )

    # Disable garbage collection while executing a python task, because some
    # Legate objects perform Legion runtime calls in their destructor (e.g.
    # LogicalStore can launch a Discard operation), which are not allowed in
    # leaf tasks. See https://github.com/nv-legate/legate.internal/issues/2261.
    #
    # TODO(mpapadakis): We should make sure we never relinquish the GIL
    # and get context-switched out to the main thread (e.g. by calling a
    # runtime function). Otherwise that thread would be executing with
    # garbage collection disabled
    cdef bool gc_enabled_at_entry = gc.isenabled()

    if gc_enabled_at_entry:
        gc.disable()

    try:
        py_callback(ctx)
    finally:
        if gc_enabled_at_entry:
            gc.enable()


cdef void abort_process(object exception) noexcept:
    cdef std_string abort_message

    try:
        abort_message = str(exception).encode()
    except:  # noqa E722
        # couldn't even encode, something is truly wrong
        abort_message = "Unknown error occurred"

    # We failed to set the exception for some reason. There is not
    # much that can really go wrong with that, so if that happened
    # we are well and truly hosed. Try one last ditch effort to
    # inform the user, and then abort
    LEGATE_ABORT("Unhandled Python exception: ", abort_message)

# This is a public variable used for testing the cache.
_TLS_CACHE_HIT_COUNTER = 0

# We must mark this function as noexcept (and indeed it is), otherwise Cython
# generates error handling code at the callsite. This is undesirable, because
# we want the generated code to look exactly like:
#
# ```
# PyEval_AcquireThread(...);
# py_variant_with_gil(ctx);
# PyEval_RealeaseThread(...);
# return
# ```
#
# It is critical that we return immediately to C++ land after we release the
# Python threadstate, since we also release the GIL at that time. The error
# handling code generated by cython, on the other hand, ends up looking like:
#
# ```
# PyEval_AcquireThread(...);
# py_variant_with_gil(ctx);
# if (PyErr_Occurred()) {
#   goto error_handling;
# }
# PyEval_ReleaseThread(...);
# return;
#
# error_handling:
# ACQUIRE_GIL
# ...
# RELEASE_GIL
# return;
# ```
#
# Which clearly skips our thread release...
cdef void py_variant_with_gil "py_variant_with_gil" (
    _TaskContext ctx,
    bool cache_hit
) noexcept:
    cdef TaskContext py_ctx

    # Need to do this in here (because it is marked as "with gil"), because
    # Cython doesn't know we hold the GIL in legate_python_task_entry()
    try:
        global _TLS_CACHE_HIT_COUNTER

        _TLS_CACHE_HIT_COUNTER += cache_hit
    except Exception as e:
        abort_process(e)

    try:
        py_ctx = TaskContext.from_handle(&ctx)
    except Exception as e:
        # If we cannot even create the TaskContext, then the only thing to
        # do is abort
        abort_process(e)

    try:
        py_variant_inner(py_ctx)
    except Exception as e:
        # Cython does not know how to throw C++ exceptions, so we have to
        # tell the context to throw them later
        try:
            py_ctx.set_exception(e)
        except Exception as e2:
            abort_process(e2)


cdef extern from "Python.h":
    ctypedef struct PyInterpreterState:
        pass

    PyInterpreterState *PyInterpreterState_Get() with gil

# Per docs of PyInterpreterState_Get()
# (https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_Get):
#
# Get the current interpreter. Issue a fatal error if there no current Python
# thread state or no current interpreter. It cannot return NULL. The caller
# must hold the GIL.
#
# These global variables are initialized on module startup, during which we are
# guaranteed to hold the GIL (specifically, the main thread will).
#
# Note, this is also why this declaration must stay in Python-land instead of
# in raw C++. We want Cython to initialize this when the Python module is
# loaded by Python, which is not necessarily when the .so is dlopened.
cdef PyInterpreterState *_INTERP_STATE = PyInterpreterState_Get()

# Need this getter because:
#
# 1. Cython defines all cdef variables as static.
# 2. The inline C++ below needs to reference MAIN_THREAD_INTERP_STATE.
# 3. But Cython puts inline C++ *above* the Cython declarations.
# 4. You cannot forward-declare static variables.
# 5. But you *can* forward declare static functions.
cdef PyInterpreterState * MAIN_THREAD_INTERP_STATE "MAIN_THREAD_INTERP_STATE" (

) noexcept nogil:
    return _INTERP_STATE

# NOTE: The AutoPyThreadState is in thread_local storage. This is deliberate!
#
# It seems that multiple threads cannot use the same PyThreadState
# independently, even if concurrent execution is blocked by the GIL. Putting
# the storage in pure static storage, resulted in a bunch of cryptic:
#
# Fatal Python error: _PyThreadState_Attach: non-NULL old thread state
# Python runtime state: initialized
#
# Errors intermittently when someone else tried to call
# `PyGILState_Ensure()`. It's not documented on the Python documentation, but
# my best guess is that PyThreadState does actually hold thread-specific
# information in it, and so having multiple threads use it is not kosher...
#
# Unfortunately, there is also no clean or universally safe way to explicitly
# destroy these PyThreadState objects. In our case, we intentionally retain
# them across the lifetime of the process because CuPy caches expensive
# resources (GPU contexts, memory pools, streams) on a per-thread-state basis.
#
# Cleaning up these thread states during interpreter shutdown is dangerous,
# because:
#
# - The Python interpreter may already be in the process of finalizing
#   (Py_Finalize() or internal teardown).
# - During finalization, many core systems (like the GIL, interpreter state, or
#   Python objects) may already be partially or fully deconstructed.
# - Calling most Python C API functions at this point is unsafe and can result
#   in undefined behavior, memory corruption, or fatal interpreter errors
#   (e.g. "_PyThreadState_Attach: non-NULL old thread state").
#
# We also cannot rely on `atexit` handlers either to perform cleanup because
# they are invoked *after* the interpreter has begun shutting down. At that
# point:
#
# - Thread-local state may be destroyed.
# - Modules and types may be unavailable or already finalized.
# - You are no longer guaranteed to be able to acquire the GIL or interact
#   safely with PyThreadState objects.
#
# A more robust solution would require a user-controlled explicit shutdown
# phase (for example, doing this in `Runtime.finish()`, which is explicitly
# called by the user before Python exits).
#
# But we cannot assume users will do this, so we err on the side of safety by
# not requiring automatic cleanup. We try our best to do it in
# ~AutoPyThreadState(), but there is no guarantee it actually ever fires.
cdef extern from "Python.h":
    r"""
    namespace {

    // Py_IsFinalizing(), only since 3.13. Cython does not support it yet, so
    // we have to do this manually...
    #if PY_VERSION_HEX >= 0x030D00A1
    #  define LEGATE_PY_IS_FINALIZING() Py_IsFinalizing()
    #else
    // Technically 3.7+ but our floor is 3.11, so it's OK not to check versions
    // here
    #  define LEGATE_PY_IS_FINALIZING() _Py_IsFinalizing()
    #endif

    class AutoPyThreadState {
    public:
      AutoPyThreadState(PyThreadState *state) : state{state}
      {
      }

      // The destructor for this class should only run when the thread holding
      // instances of this gets deleted. So we should take care that
      // AutoPyThreadState is never copied or moved
      AutoPyThreadState(const AutoPyThreadState &) = delete;
      AutoPyThreadState& operator=(const AutoPyThreadState &) = delete;
      AutoPyThreadState(AutoPyThreadState &&) = delete;
      AutoPyThreadState& operator=(AutoPyThreadState &&) = delete;

      ~AutoPyThreadState()
      {
        if (state && !LEGATE_PY_IS_FINALIZING()) {
          PyEval_AcquireThread(state);
          PyThreadState_Clear(state);
          PyThreadState_DeleteCurrent();
        }
      }

      PyThreadState *state{};
    };

    } // namespace
    """

# This code must be in pure C++, because we want to be very deliberate with the
# generated code, and Cython is simply too wishy-washy here. In particular, we
# do not want Cython to:
#
# 1. Generate any Python GIL acquiring code (under any circumstances).
# 2. Generate any Python error handling (which in turn causes GIL acquiring).
#
# Furthermore, we also have the thread_local cache business, which Cython does
# not understand.
cdef extern from "legate/task/task_context.h":
    r"""
    #include <Python.h>
    #include <optional>

    static void py_variant_with_gil(legate::TaskContext, bool);
    static PyInterpreterState *MAIN_THREAD_INTERP_STATE();

    namespace {

    void clear_and_destroy_threadstate(PyThreadState *tstate)
    {
      PyThreadState_Clear(tstate);
      PyThreadState_DeleteCurrent();  // Releases GIL
    }

    void legate_python_task_entry(legate::TaskContext ctx)
    {
      thread_local std::optional<AutoPyThreadState> cache{};

      PyThreadState *tstate{};
      bool           cache_hit{};

      if (cache.has_value()) {
        tstate = std::exchange(cache->state, nullptr);
        cache.reset();
        cache_hit = true;
      } else {
        tstate = PyThreadState_New(MAIN_THREAD_INTERP_STATE());
      }

      PyEval_AcquireThread(tstate); // Acquires GIL

      try {
        py_variant_with_gil(ctx, cache_hit);
      } catch (...) {
        clear_and_destroy_threadstate(tstate);
        throw;
      }

      if (cache.has_value()) {
        clear_and_destroy_threadstate(tstate);
      } else {
        PyEval_ReleaseThread(tstate); // releases GIL
        // Note, we do not need to hold the GIL for this, because the only
        // other thread that has access to our cache is... ourselves.
        cache.emplace(tstate);
      }
    }

    } // namespace
    """
    void legate_python_task_entry "legate_python_task_entry" (
        _TaskContext ctx
    ) noexcept nogil

cdef extern from "legate/task/variant_helper.h" nogil:
    r"""
    namespace {

    std::unordered_map<legate::VariantCode, legate::Processor::TaskFuncPtr>
    init_vmap()
    {
      return {
        {
          legate::VariantCode::CPU,
          legate::detail::task_wrapper_dyn_name<legate_python_task_entry,
                                                legate::VariantCode::CPU>
        },
        {
          legate::VariantCode::GPU,
          legate::detail::task_wrapper_dyn_name<legate_python_task_entry,
                                                legate::VariantCode::GPU>
        },
        {
          legate::VariantCode::OMP,
          legate::detail::task_wrapper_dyn_name<legate_python_task_entry,
                                                legate::VariantCode::OMP>
        }
      };
    }

    } // namespace
    """
    std_unordered_map[VariantCode, TaskFuncPtr] init_vmap()

cdef std_unordered_map[VariantCode, TaskFuncPtr] _variant_to_callback = \
    init_vmap()


# Need to put this in a separate function because:
#
# 1. We need access to TaskInfo::AddVariantKey, and declaring nested C++
#    classes in Cython is a huge PITA. So it's easier to just write it out in
#    raw C++.
# 2. We need to control the name of the function. If we were to use a raw
#    Cython function, cython would mangle it. So we define the body in C++, and
#    tell Cython exactly what the name should be. Also, we want it in a
#    specific namespace because it makes the resulting friend decl in C++ more
#    obviously "Cython".
cdef extern from "legate/task/task_info.h" nogil:
    r"""
    namespace legate::detail::cython {

    void cytaskinfo_add_variant(
      legate::TaskInfo *handle,
      const legate::Library &core_lib,
      legate::VariantCode variant_kind,
      legate::VariantImpl cy_entry,
      legate::Processor::TaskFuncPtr py_entry,
      const legate::TaskConfig& config)
    {
      handle->add_variant_(
        legate::TaskInfo::AddVariantKey{},
        core_lib,
        variant_kind,
        cy_entry,
        py_entry,
        config,
        /* decl_options */ nullptr
      );
    }

    } // namespace legate::detail::cython
    """
    void cytaskinfo_add_variant \
        "legate::detail::cython::cytaskinfo_add_variant" (
            _TaskInfo *,
            const _Library&,
            VariantCode,
            VariantImpl,
            TaskFuncPtr,
            const _TaskConfig&
        ) except+


cdef void finalize_variant_registration(
    TaskInfo task_info, TaskConfig config, Library library, VariantCode code
):
    cdef TaskFuncPtr entry

    try:
        entry = _variant_to_callback[code]
    except KeyError as ke:
        m = f"Unknown variant '{code}'"
        raise ValueError(m) from ke

    with nogil:
        cytaskinfo_add_variant(
            &task_info._handle,
            library._handle,
            code,
            legate_python_task_entry,
            entry,
            config._handle
        )
