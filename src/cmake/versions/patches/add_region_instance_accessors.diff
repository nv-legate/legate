diff --git a/runtime/legion/api/accessors.h b/runtime/legion/api/accessors.h
index 3fd7cba79..cb7caaa79 100644
--- a/runtime/legion/api/accessors.h
+++ b/runtime/legion/api/accessors.h
@@ -137,6 +137,73 @@ namespace Legion {
         bool check_field_size = true,
 #else
         bool check_field_size = false,
+#endif
+        bool silence_warnings = false, const char* warning_string = nullptr,
+        size_t subfield_offset = 0)
+    { }
+    // Create a field accessor for a raw Realm::RegionInstance
+    FieldAccessor(
+        const Realm::RegionInstance& instance, Realm::FieldID fid,
+        // The actual field size in case it is different from the
+        // one being used in FT and we still want to check it
+        size_t actual_field_size = sizeof(FT),
+#ifdef LEGION_DEBUG
+        bool check_field_size = true,
+#else
+        bool check_field_size = false,
+#endif
+        bool silence_warnings = false, const char* warning_string = nullptr,
+        size_t subfield_offset = 0)
+    { }
+    // For Realm::AffineAccessor specializations there are additional
+    // methods for creating accessors with limited bounding boxes and
+    // affine transformations for using alternative coordinates spaces
+    // Specify a specific bounds rectangle to use for the accessor
+    FieldAccessor(
+        const Realm::RegionInstance& instance, Realm::FieldID fid,
+        const Rect<N, COORD_T> bounds,
+        // The actual field size in case it is different from the
+        // one being used in FT and we still want to check it
+        size_t actual_field_size = sizeof(FT),
+#ifdef LEGION_DEBUG
+        bool check_field_size = true,
+#else
+        bool check_field_size = false,
+#endif
+        bool silence_warnings = false, const char* warning_string = nullptr,
+        size_t subfield_offset = 0)
+    { }
+    // Specify a specific Affine transform to use for interpreting points
+    // Not available for Realm::MultiAffineAccessor specializations
+    template<int M>
+    FieldAccessor(
+        const Realm::RegionInstance& instance, Realm::FieldID fid,
+        const AffineTransform<M, N, COORD_T> transform,
+        // The actual field size in case it is different from the
+        // one being used in FT and we still want to check it
+        size_t actual_field_size = sizeof(FT),
+#ifdef LEGION_DEBUG
+        bool check_field_size = true,
+#else
+        bool check_field_size = false,
+#endif
+        bool silence_warnings = false, const char* warning_string = nullptr,
+        size_t subfield_offset = 0)
+    { }
+    // Specify both a transform and a bounds to use
+    // Not available for Realm::MultiAffineAccessor specializations
+    template<int M>
+    FieldAccessor(
+        const Realm::RegionInstance& instance, Realm::FieldID fid,
+        const AffineTransform<M, N, COORD_T> transform,
+        const Rect<N, COORD_T> bounds,
+        // The actual field size in case it is different from the
+        // one being used in FT and we still want to check it
+        size_t actual_field_size = sizeof(FT),
+#ifdef LEGION_DEBUG
+        bool check_field_size = true,
+#else
+        bool check_field_size = false,
 #endif
         bool silence_warnings = false, const char* warning_string = nullptr,
         size_t subfield_offset = 0)
@@ -443,6 +510,38 @@ namespace Legion {
 #endif
     )
     { }
+  // For Realm::AffineAccessor specializations there are additional
+  // methods for creating accessors with limited bounding boxes and
+  // affine transformations for using alternative coordinates spaces
+  // Specify a specific bounds rectangle to use for the accessor
+  ReductionAccessor(
+      const Realm::RegionInstance& instance, Realm::FieldID fid,
+      const Rect<N, COORD_T> bounds, bool silence_warnings = false,
+      const char* warning_string = nullptr, size_t subfield_offset = 0,
+      size_t actual_field_size = sizeof(typename REDOP::RHS),
+#ifdef LEGION_DEBUG
+      bool check_field_size = true
+#else
+      bool check_field_size = false
+#endif
+  )
+  { }
+  // Specify both a transform and a bounds to use
+  // Not available for Realm::MultiAffineAccessor specializations
+  template<int M>
+  ReductionAccessor(
+      const Realm::RegionInstance& instance, Realm::FieldID fid,
+      const AffineTransform<M, N, COORD_T> transform,
+      const Rect<N, COORD_T> bounds, bool silence_warnings = false,
+      const char* warning_string = nullptr, size_t subfield_offset = 0,
+      size_t actual_field_size = sizeof(typename REDOP::RHS),
+#ifdef LEGION_DEBUG
+      bool check_field_size = true
+#else
+      bool check_field_size = false
+#endif
+  )
+  { }
   public:
     // Variations of the same four methods above but with multiple
     // physical regions specified using input iterators for colocation regions
diff --git a/runtime/legion/api/accessors.inl b/runtime/legion/api/accessors.inl
index 95255df83..0c8785d75 100644
--- a/runtime/legion/api/accessors.inl
+++ b/runtime/legion/api/accessors.inl
@@ -1617,6 +1617,67 @@ namespace Legion {
         instance, transform.transform, transform.offset, fid, source_bounds,   \
         offset);                                                               \
   }                                                                            \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      size_t actual_field_size = sizeof(FT),                                   \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+  {                                                                            \
+    DomainT<DIM, T> is;                                                        \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, fid, is.bounds))                                         \
+      assert(false && "Incompatible accessor");                                \
+    accessor =                                                                 \
+        Realm::AffineAccessor<FT, DIM, T>(instance, fid, is.bounds, offset);   \
+  }                                                                            \
+  /* With explicit bounds */                                                   \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const Rect<DIM, T> source_bounds, size_t actual_field_size = sizeof(FT), \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+  {                                                                            \
+    DomainT<DIM, T> is;                                                        \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, fid, source_bounds))                                     \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, fid, source_bounds, offset);                                 \
+  }                                                                            \
+  /* With explicit transform */                                                \
+  template<int M>                                                              \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const AffineTransform<M, DIM, T> transform,                              \
+      size_t actual_field_size = sizeof(FT),                                   \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+  {                                                                            \
+    DomainT<M, T> is;                                                          \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, transform.transform, transform.offset, fid))             \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, transform.transform, transform.offset, fid, offset);         \
+  }                                                                            \
+  /* With explicit transform and bounds */                                     \
+  template<int M>                                                              \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const AffineTransform<M, DIM, T> transform,                              \
+      const Rect<DIM, T> source_bounds, size_t actual_field_size = sizeof(FT), \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+  {                                                                            \
+    DomainT<M, T> is;                                                          \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, transform.transform, transform.offset, fid,              \
+            source_bounds))                                                    \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, transform.transform, transform.offset, fid, source_bounds,   \
+        offset);                                                               \
+  }                                                                            \
   /* colocation regions */                                                     \
   template<typename InputIterator>                                             \
   FieldAccessor(                                                               \
@@ -1853,6 +1914,75 @@ namespace Legion {
         offset);                                                               \
     bounds = AffineBounds::Tester<DIM, T>(is, source_bounds, transform);       \
   }                                                                            \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      size_t actual_field_size = sizeof(FT),                                   \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+    : field(fid)                                                               \
+  {                                                                            \
+    DomainT<DIM, T> is;                                                        \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, fid, is.bounds))                                         \
+      assert(false && "Incompatible accessor");                                \
+    accessor =                                                                 \
+        Realm::AffineAccessor<FT, DIM, T>(instance, fid, is.bounds, offset);   \
+    bounds = AffineBounds::Tester<DIM, T>(is);                                 \
+  }                                                                            \
+  /* With explicit bounds */                                                   \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const Rect<DIM, T> source_bounds, size_t actual_field_size = sizeof(FT), \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+    : field(fid)                                                               \
+  {                                                                            \
+    DomainT<DIM, T> is;                                                        \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, fid, source_bounds))                                     \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, fid, source_bounds, offset);                                 \
+    bounds = AffineBounds::Tester<DIM, T>(is, source_bounds);                  \
+  }                                                                            \
+  /* With explicit transform */                                                \
+  template<int M>                                                              \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const AffineTransform<M, DIM, T> transform,                              \
+      size_t actual_field_size = sizeof(FT),                                   \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+    : field(fid)                                                               \
+  {                                                                            \
+    DomainT<M, T> is;                                                          \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, transform.transform, transform.offset, fid))             \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, transform.transform, transform.offset, fid, offset);         \
+    bounds = AffineBounds::Tester<DIM, T>(is, transform);                      \
+  }                                                                            \
+  /* With explicit transform and bounds */                                     \
+  template<int M>                                                              \
+  FieldAccessor(                                                               \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,               \
+      const AffineTransform<M, DIM, T> transform,                              \
+      const Rect<DIM, T> source_bounds, size_t actual_field_size = sizeof(FT), \
+      bool check_field_size = FIELD_CHECK, bool silence_warnings = false,      \
+      const char* warning_string = nullptr, size_t offset = 0)                 \
+    : field(fid)                                                               \
+  {                                                                            \
+    DomainT<M, T> is;                                                          \
+    if (!Realm::AffineAccessor<FT, DIM, T>::is_compatible(                     \
+            instance, transform.transform, transform.offset, fid,              \
+            source_bounds))                                                    \
+      assert(false && "Incompatible accessor");                                \
+    accessor = Realm::AffineAccessor<FT, DIM, T>(                              \
+        instance, transform.transform, transform.offset, fid, source_bounds,   \
+        offset);                                                               \
+    bounds = AffineBounds::Tester<DIM, T>(is, source_bounds, transform);       \
+  }                                                                            \
   /* colocation regions */                                                     \
   template<typename InputIterator>                                             \
   FieldAccessor(                                                               \
@@ -4067,6 +4197,38 @@ namespace Legion {
         instance, transform.transform, transform.offset, fid, source_bounds,  \
         offset);                                                              \
   }                                                                           \
+  /* With explicit bounds */                                                  \
+  ReductionAccessor(                                                          \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,              \
+      const Rect<DIM, T> source_bounds, bool silence_warnings = false,        \
+      const char* warning_string = nullptr, size_t offset = 0,                \
+      size_t actual_field_size = sizeof(typename REDOP::RHS),                 \
+      bool check_field_size = FIELD_CHECK)                                    \
+  {                                                                           \
+    if (!Realm::AffineAccessor<typename REDOP::RHS, DIM, T>::is_compatible(   \
+            instance, fid, source_bounds))                                    \
+      assert(false && "Incompatible accessor");                               \
+    accessor = Realm::AffineAccessor<typename REDOP::RHS, DIM, T>(            \
+        instance, fid, source_bounds, offset);                                \
+  }                                                                           \
+  /* With explicit transform and bounds */                                    \
+  template<int M>                                                             \
+  ReductionAccessor(                                                          \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,              \
+      const AffineTransform<M, DIM, T> transform,                             \
+      const Rect<DIM, T> source_bounds, bool silence_warnings = false,        \
+      const char* warning_string = nullptr, size_t offset = 0,                \
+      size_t actual_field_size = sizeof(typename REDOP::RHS),                 \
+      bool check_field_size = FIELD_CHECK)                                    \
+  {                                                                           \
+    if (!Realm::AffineAccessor<typename REDOP::RHS, DIM, T>::is_compatible(   \
+            instance, transform.transform, transform.offset, fid,             \
+            source_bounds))                                                   \
+      assert(false && "Incompatible accessor");                               \
+    accessor = Realm::AffineAccessor<typename REDOP::RHS, DIM, T>(            \
+        instance, transform.transform, transform.offset, fid, source_bounds,  \
+        offset);                                                              \
+  }                                                                           \
   /* colocation regions */                                                    \
   template<typename InputIterator>                                            \
   ReductionAccessor(                                                          \
@@ -4320,6 +4482,44 @@ namespace Legion {
         offset);                                                              \
     bounds = AffineBounds::Tester<DIM, T>(is, source_bounds, transform);      \
   }                                                                           \
+  /* With explicit bounds */                                                  \
+  ReductionAccessor(                                                          \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,              \
+      const Rect<DIM, T> source_bounds, bool silence_warnings = false,        \
+      const char* warning_string = nullptr, size_t offset = 0,                \
+      size_t actual_field_size = sizeof(typename REDOP::RHS),                 \
+      bool check_field_size = FIELD_CHECK)                                    \
+    : field(fid)                                                              \
+  {                                                                           \
+    DomainT<DIM, T> is;                                                       \
+    if (!Realm::AffineAccessor<typename REDOP::RHS, DIM, T>::is_compatible(   \
+            instance, fid, source_bounds))                                    \
+      assert(false && "Incompatible accessor");                               \
+    accessor = Realm::AffineAccessor<typename REDOP::RHS, DIM, T>(            \
+        instance, fid, source_bounds, offset);                                \
+    bounds = AffineBounds::Tester<DIM, T>(is, source_bounds);                 \
+  }                                                                           \
+  /* With explicit transform and bounds */                                    \
+  template<int M>                                                             \
+  ReductionAccessor(                                                          \
+      const Realm::RegionInstance& instance, Realm::FieldID fid,              \
+      const AffineTransform<M, DIM, T> transform,                             \
+      const Rect<DIM, T> source_bounds, bool silence_warnings = false,        \
+      const char* warning_string = nullptr, size_t offset = 0,                \
+      size_t actual_field_size = sizeof(typename REDOP::RHS),                 \
+      bool check_field_size = FIELD_CHECK)                                    \
+    : field(fid)                                                              \
+  {                                                                           \
+    DomainT<M, T> is;                                                         \
+    if (!Realm::AffineAccessor<typename REDOP::RHS, DIM, T>::is_compatible(   \
+            instance, transform.transform, transform.offset, fid,             \
+            source_bounds))                                                   \
+      assert(false && "Incompatible accessor");                               \
+    accessor = Realm::AffineAccessor<typename REDOP::RHS, DIM, T>(            \
+        instance, transform.transform, transform.offset, fid, source_bounds,  \
+        offset);                                                              \
+    bounds = AffineBounds::Tester<DIM, T>(is, source_bounds, transform);      \
+  }                                                                           \
   /* colocation regions*/                                                     \
   template<typename InputIterator>                                            \
   ReductionAccessor(                                                          \
